

# 정렬 알고리즘 소개

https://www.toptal.com/developers/sorting-algorithms

**정렬의 정의**

- 정렬 알고리즘은 컬렉션의 항목을 재배열하는 과정입니다.
- 예를 들어, 배열 내의 숫자나 문자열을 오름차순 또는 내림차순으로 정렬할 수 있습니다.
- 다른 데이터 구조(목록, 트리)에도 적용될 수 있지만, 지금은 배열에 집중합니다.

**정렬 알고리즘의 중요성**

- 정렬은 프로그래밍에서 흔히 사용됩니다.
- 내장 정렬 메소드의 작동 방식을 이해하면, 적절한 상황에 맞게 사용할 수 있습니다.
- 면접에서 자주 다뤄지는 주제로, 비판적 사고와 문제 해결 능력을 평가할 수 있는 좋은 도전 과제입니다.

# 기본 내장 자바스크립트 정렬

### Array.sort() 메소드

**기본 정렬 메소드**

- 기본적으로 array.sort()는 **문자열을 유니코드 코드 포인트 순으로 정렬**합니다.
- **문자열 배열은 예상대로 알파벳순으로 정렬**됩니다.
- **숫자 배열은 예상치 못한 순서로 정렬될 수 있습니다**. 예: [6, 4, 15, 10]이 [10, 15, 4, 6]으로 정렬됨.

**정렬 동작 이해**

- **기본 정렬은 배열의 모든 항목을 문자열로 변환**하고, 해당 **문자열의 유니코드 값을 기준으로 정렬**합니다.
- 이를 통해 숫자 배열이 예상치 못한 순서로 정렬될 수 있습니다.

**비교 함수 사용**

- **array.sort() 메소드는 선택적으로 비교 함수(comparator function)를 인자로 받을 수 있습니다.**
- 이 함수는 두 항목(a와 b)을 비교하여 음수, 양수 또는 0을 반환합니다.
    - 음수를 반환하면 a가 b 앞에 오고, 양수를 반환하면 b가 a 앞에 오며, 0을 반환하면 두 항목이 동일하게 취급됩니다.

> **내장 정렬 메소드는 매우 유용하며, 비교 함수를 사용하면 원하는 방식으로 정렬을 커스터마이징**할 수 있습니다.
> 

# 버블 정렬 : 개요

https://visualgo.net/en/sorting?slide=1

1. **비효율성**: 버블 정렬은 효율적이지 않으며, 일반적으로 사용되지 않습니다. 특정 유스 케이스에서만 유용합니다.
2. **알고리즘 설명**:
    - **배열을 오름차순으로 정렬할 때, 큰 숫자가 한 번에 하나씩 뒤로 이동합니다.**
    - **각 항목을 다음 항목과 비교하고, 더 큰 경우 교환(swap)합니다.**
    - **이 과정을 배열의 끝까지 반복하면 가장 큰 숫자가 배열의 끝으로 이동합니다.**
3. **비주알고**:
    - 브라우저에서 사용할 수 있는 인터랙티브 툴로, 정렬 알고리즘을 시각적으로 이해하는 데 도움을 줍니다.
4. **작동 과정**:
    - 루프를 돌면서 인접한 항목을 비교하고, 필요시 교환합니다.
    - 첫 번째 반복에서 가장 큰 값이 배열의 끝으로 이동합니다.
    - 두 번째 반복에서는 배열의 끝에 있는 값을 제외한 나머지 항목들을 정렬합니다.
    - 이를 반복하면 정렬이 완료됩니다.

### 교환(swap) 방법

1. **전통적인 방법**:
    - `temp` 변수를 사용해 두 값을 교환하는 방식.
2. **ES2015 방식**:
    - 간단한 구문을 사용해 한 줄로 두 값을 교환하는 방식.

### 버블 정렬 구현

1. **함수 정의**:
    - `bubbleSort` 함수를 정의하고, 배열을 인자로 받습니다.
2. **루프 구조**:
    - 외부 루프: 배열의 끝에서 시작해 앞으로 진행합니다.
    - 내부 루프: 배열의 처음부터 외부 루프의 현재 인덱스까지 실행합니다.
3. **비교 및 교환**:
    - `arr[j]`와 `arr[j+1]`을 비교해 더 큰 경우 교환합니다.
4. **정렬된 배열 반환**:
    - 루프가 완료된 후 정렬된 배열을 반환합니다.

# 버블 정렬 : 구현

### 버블 정렬 기본 개념

버블 정렬은 인접한 두 요소를 비교하여 순서가 잘못된 경우 교환하는 방식으로 배열을 정렬합니다. 이 과정은 배열이 정렬될 때까지 반복됩니다. 일반적으로 시간 복잡도는 \(O(n^2)\)입니다.

### 구현 단계

1. **기본 아이디어**
    - 배열의 맨 앞에서 시작하여 인접한 두 요소를 비교하고 필요하면 교환합니다.
    - 배열의 끝까지 한 번 통과하면 가장 큰 요소가 맨 끝에 위치합니다.
    - 이를 반복하여 배열을 정렬합니다.
2. **기본 버블 정렬 구현**
    - 배열의 길이만큼 외부 루프를 실행합니다.
    - 내부 루프는 배열의 처음부터 끝까지 요소를 비교하고 교환합니다.
    - 내부 루프가 끝날 때마다 배열의 끝부분에서 정렬된 요소는 다시 비교하지 않도록 범위를 줄입니다.

```jsx
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}

let arr = [37, 45, 29, 8];
console.log(bubbleSort(arr)); // [8, 29, 37, 45]

```

1. **최적화된 버전**
    - 배열의 마지막 부분이 이미 정렬된 경우 이를 고려하여 비교 범위를 줄입니다.
    - 외부 루프는 배열의 끝에서 시작하여 앞으로 진행합니다.
    - 내부 루프는 정렬이 완료된 부분을 제외하고 실행합니다.

```jsx
function optimizedBubbleSort(arr) {
    for (let i = arr.length; i > 0; i--) {
        for (let j = 0; j < i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}

let arr = [37, 45, 29, 8];
console.log(optimizedBubbleSort(arr)); // [8, 29, 37, 45]

```

1. **ES6 버전**
    - 최신 JavaScript 문법을 사용하여 코드를 간결하게 작성합니다.
    - `let`과 화살표 함수(arrow function)를 사용하여 가독성을 높입니다.

```jsx
function bubbleSort(arr) {
  const swap = (arr, idx1, idx2) => {  
	  // 배열의 두 요소를 교환하는 함수
	  // 인자로 배열 arr와 교환할 두 인덱스 idx1, idx2를 받습니다.
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
	    // 배열 디스트럭처링 할당([arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]])을 
	    // 사용하여 두 요소의 값을 교환합니다.
  };

  for (let i = arr.length; i > 0; i--) {
  //외부 루프는 배열의 끝에서 시작하여 앞으로 진행합니다.i는 배열의 길이에서 1씩 줄어듭니다.
    for (let j = 0; j < i - 1; j++) {
    //내부 루프는 배열의 처음부터 i - 1까지의 요소를 순회하며 인접한 두 요소를 비교합니다.
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
       //만약 현재 요소(arr[j])가 다음 요소(arr[j + 1])보다 크면 swap 함수를 사용하여 두 요소를 교환합니다.
      }
    }
  }
  return arr;
}

```
### 동작 원리

1. 외부 루프는 배열의 끝에서 시작하여 처음까지 감소합니다. 이는 내부 루프의 범위를 점점 줄이기 위함입니다.
2. 내부 루프는 배열의 처음부터 외부 루프의 현재 인덱스 전까지 순회합니다.
3. 내부 루프에서 인접한 두 요소를 비교하여 앞의 요소가 더 크면 `swap` 함수를 사용하여 두 요소를 교환합니다.
4. 외부 루프가 한 번 돌 때마다 가장 큰 요소가 배열의 끝에 배치됩니다.
5. 이 과정을 배열이 정렬될 때까지 반복합니다.

### 예제 설명

- 첫 번째 예제에서 `[5, 3, 8, 4, 2]`는 버블 정렬 알고리즘에 의해 `[2, 3, 4, 5, 8]`로 정렬됩니다.
- 두 번째 예제에서 `[1, 2, 3, 4, 5]`는 이미 정렬된 상태이므로 변경되지 않고 그대로 반환됩니다.
- 세 번째 예제에서 `[5, 4, 3, 2, 1]`은 버블 정렬에 의해 `[1, 2, 3, 4, 5]`로 정렬됩니다.
- 네 번째 예제에서 `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`는 중복 요소를 포함하고 있으며, 버블 정렬을 통해 `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]`로 정렬됩니다.

### 요약

- 버블 정렬은 인접한 요소를 반복적으로 비교하고 교환하여 배열을 정렬하는 간단한 알고리즘입니다.
- 기본 버전은 모든 요소를 반복적으로 비교하며, 최적화된 버전은 불필요한 비교를 줄입니다.
- ES6 버전을 통해 더 간결하고 현대적인 JavaScript 코드를 작성할 수 있습니다.